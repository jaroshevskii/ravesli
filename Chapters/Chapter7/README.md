# Глава №7. Итоговый тест

Страница на [Ravesli](https://ravesli.com/glava-7-itogovyj-test/).

Еще одна глава пройдена! Впереди самое сердце этого туториала — объектно-ориентированное программирование, мы почти добрались! Осталась всего лишь одна ступенька — итоговый тест.

**Оглавление:**

1. [Теория](#теория)
2. [Задание №1](#задание-1)
3. [Задание №2](#задание-2)
4. [Задание №3](#задание-3)

## Теория

Аргументы функций могут передаваться по значению, по ссылке или по адресу. Используйте:
- `передачу по значению` для фундаментальных типов данных и перечислителей;
- `передачу по (константной) ссылке` для структур, классов или в тех случаях, когда нужно, чтобы функция изменяла значение аргумента;
- `передачу по адресу` для указателей или обычных массивов.

В большинстве случаев используется `возврат по значению`, однако `возврат по ссылке` или `по адресу` также может быть полезен при работе с динамически выделенными массивами, структурами или классами. Если используете возврат по ссылке или по адресу, то убедитесь, что не возвращаете чего-то, что выйдет из локальной области видимости.

С помощью `встроенных функций` вызов функции можно заменить на непосредственный код этой функции.

`Перегрузка функций` позволяет создать несколько функций с одним и тем же именем, но при условии, что параметры этих функций будут разные. Возвращаемое значение не считается параметром.

`Параметр по умолчанию` — это параметр функции, который имеет значение по умолчанию. Если caller не передает значение для параметра, то будет использоваться значение по умолчанию. У вас может быть несколько параметров со значениями по умолчанию. Они всегда должны находиться справа от обычных параметров. Параметр по умолчанию может быть установлен только в одном месте. Обычно его размещают в предварительном объявлении функции. Если же предварительного объявления нет, то его размещают в определении функции.

`Указатели на функции` позволяют передать одну функцию в качестве аргумента другой функции.

Динамическая память выделяется из `кучи`.

`Стек вызовов` отслеживает все активные функции (те, которые были вызваны, но еще не завершены) от начала программы и до текущей точки выполнения. Стек имеет ограниченный размер.

`std::vector` можно использовать в качестве стека.

`Рекурсивная функция` — это функция, которая вызывает сама себя. Для всех рекурсивных функций требуется условие завершения.

`Синтаксическая ошибка` возникает, когда вы пишете код, который нарушает правила грамматики языка C++. Компилятор такие ошибки легко отлавливает.

`Семантическая ошибка` возникает, когда код синтаксически правильный, но выполняет не то, что нужно программисту. Среди семантических ошибок распространены `логические ошибки` и `ложные предположения`.

`Стейтмент assert` используется для обнаружения ложных предположений, но его недостаток заключается в том, что при ложном утверждении выполнение программы немедленно прекращается.

`Аргументы командной строки` позволяют пользователям или другим программам передавать данные в программу при её запуске. Аргументы командной строки всегда являются строками C-style и для использования числовых значений вам нужно будет конвертировать строки в числовые типы данных.

`Эллипсис` позволяет передать переменную, указывающую на количество всех передаваемых аргументов, в функцию. Однако при таком раскладе игнорируется проверка типов, что крайне нежелательно и может привести к проблемам.

## Тест

### Задание №1

Напишите прототипы функций для следующих случаев. Используйте const при необходимости.

a) Функция с именем max(), которая принимает два значения типа double и возвращает большее из них.

b) Функция swap(), которая меняет местами два целых числа.

c) Функция getLargestElement(), которая принимает динамически выделенный массив целых чисел и возвращает наибольшее число таким образом, что caller может изменить значение возвращаемого элемента (не забудьте о параметре-длине).

### Задание №2

Что не так со следующими программами?

a)
```c++
int& doSomething()
{
    int array[] = { 1, 3, 5, 7, 9 };
    return array[2];
}
```

b)
```c++
int sumTo(int value)
{
    return value + sumTo(value - 1);
}
```

c)
```c++
float divide(float a, float b)
{
    return a / b;
}
 
double divide(float a, float b)
{
    return a / b;
}
```

d)
```c++
#include <iostream>
 
int main()
{
    int array[1000000000];
 
    for (const auto &x: array)
        std::cout << x << ' ';
 
    return 0;
}
```

e)
```c++
#include <iostream>
 
int main(int argc, char *argv[])
{
    int times = argv[1];
    for (int count = 0; count < times; count++)
        std::cout << count << ' ';
 
    return 0;
}
```

### Задание №3

Лучшим алгоритмом определения того, существует ли значение в отсортированном массиве или нет, является бинарный поиск.

**Бинарный поиск работает следующим образом:**
- Смотрим на центральный элемент массива.
- Если центральный элемент массива больше элемента, который мы ищем, то всё, что находится справа от центрального элемента — отбрасываем.
- Если центральный элемент меньше элемента, который мы ищем, то отбрасываем всё, что находится слева от центрального элемента.
- Если центральный элемент равен элементу, который мы ищем, то возвращаем индекс этого элемента.
- Если перебрали весь массив и не нашли искомого значения, то возвращаем контрольное значение с выводом `not found`.

Поскольку в каждой итерации мы можем отбрасывать сразу половину массива, то скорость выполнения этого алгоритма достаточно большая. Даже с массивом в миллион элементов для определения того, существует ли конкретное значение в этом массиве или нет, потребуется не более 20 итераций! Однако бинарный поиск работает только в отсортированном массиве.

Изменение массива (например, отбрасывание половины элементов массива) является затратной операцией, поэтому обычно массив не изменяется. Вместо этого используется два целочисленных значения (min и max) для хранения индексов минимальной и максимальной границ поиска элемента в массиве.

Рассмотрим пример работы этого алгоритма с массивом `{4, 5, 7, 10, 11, 14, 19, 20, 25}` и искомым значением `7`. Сначала `min = 0`, `max = 8`, так как мы перебираем весь массив (всего элементов 9, но индекс последнего элемента равен 8).

- Итерация №1: Вычисляем среднее значение между `min` (0) и `max` (8), которое равно 4. Элемент №4 имеет значение 11, которое больше нашего искомого значения. Поскольку массив отсортирован, то мы знаем, что все элементы, которые находятся справа от индекса 4 (и индекс 4 тоже) являются больше нашего искомого числа. Поэтому `min` оставляем прежним, а `max` изменяем на 3.

- Итерация №2: Вычисляем среднее значение между `min` (0) и `max` (3), которое равно 1. Элемент №1 имеет значение 5, которое меньше нашего искомого значения. Поскольку массив отсортирован, то мы знаем, что все элементы, которые находятся слева от индекса 1 (и индекс 1 тоже) — меньше нашего искомого числа. Следовательно, `min` изменяем на 2, а `max` оставляем прежним.

- Итерация №3: Вычисляем среднее значение между `min` (2) и `max` (3), которое равно 2. Элемент №2 имеет значение 7, которое является нашим искомым значением. Возвращаем элемент №2.

Используя следующий код:
```c++
// array - это массив, в котором мы проводим поиски.
// target - это искомое значение.
// min - это индекс минимальной границы массива, в котором мы осуществляем поиск.
// max - это индекс максимальной границы массива, в котором мы осуществляем поиск.
// Функция binarySearch() должна возвращать индекс искомого значения, если он обнаружен. В противном случае, возвращаем -1
int binarySearch(int *array, int target, int min, int max)
{
 
}
 
int main()
{
	int array[] = { 4, 7, 9, 13, 15, 19, 22, 24, 28, 33, 37, 41, 43, 47, 50 };
 
	std::cout << "Enter a number: ";
	int x;
	std::cin >> x;
 
	int index = binarySearch(array, x, 0, 14);
 
	if (array[index] == x)
		std::cout << "Good! Your value " << x << " is on position "<< index << " in array!\n";
	else
		std::cout << "Fail! Your value " << x << " isn't in array!\n";
	return 0;
}
```

a) Напишите итеративную версию функции binarySearch().

b) Напишите рекурсивную версию функции binarySearch().
