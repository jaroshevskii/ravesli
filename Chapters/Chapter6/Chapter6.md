# Chapter 6

## Task 1
Представьте, что вы пишете игру, в которой игрок может иметь 3 типа предметов: зелья здоровья, факелы и стрелы. Создайте перечисление с этими типами предметов и фиксированный массив для хранения количества каждого типа предметов, которое имеет при себе игрок (используйте стандартные фиксированные массивы, а не std::array). У вашего игрока должны быть при себе 3 зелья здоровья, 6 факелов и 12 стрел. Напишите функцию countTotalItems(), которая возвращает общее количество предметов, которые есть у игрока. В функции main() выведите результат работы функции countTotalItems().

## Task 2
Создайте структуру, содержащую имя и оценку учащегося (по шкале от 0 до 100). Спросите у пользователя, сколько учеников он хочет ввести. Динамически выделите массив для хранения всех студентов. Затем попросите пользователя ввести для каждого студента его имя и оценку. Как только пользователь ввел все имена и оценки, отсортируйте список оценок студентов по убыванию (сначала самый высокий бал). Затем выведите все имена и оценки в отсортированном виде.

Для следующего ввода:
```
Andre
74
Max
85
Anton
12
Josh
17
Sasha
90
```

Вывод должен быть следующим:
```
Sasha got a grade of 90
Max got a grade of 85
Andre got a grade of 74
Josh got a grade of 17
Anton got a grade of 12
```

### ***Подсказка:***
Вы можете изменить алгоритм сортировки массива методом выбора из урока №77 для сортировки вашего динамического массива. Если вы напишете сортировку массива отдельной функцией, то массив должен передаваться по адресу (как указатель).

## Task 3
Напишите свою функцию, которая меняет местами значения двух целочисленных переменных. Проверку осуществляйте в функции main().

### ***Подсказка:***
Используйте ссылки в качестве параметров.

## Task 4
Напишите функцию для вывода строки C-style символ за символом. Используйте указатель для перехода и вывода каждого символа поочерёдно. Остановите вывод при столкновении с нуль-терминатором. В функции main() протестируйте строку `Hello, world!`.

### ***Подсказка:***
Используйте оператор ++ для перевода указателя на следующий символ.

## Task 5
Что не так с каждым из следующих фрагментов кода, и как бы вы их исправили?

a)
```c++
#include <iostream>
 
int main()
{
    int array[6] { 0, 2, 4, 7, 9 };
    for (int count = 0; count <= 6; ++count)
        std::cout << array[count] << " ";
 
    return 0;
}
```

b)
```c++
#include <iostream>
 
int main()
{
    int a = 4;
    int b = 6;
 
    const int *ptr = &a;
    std::cout << *ptr;
    *ptr = 7;
    std::cout << *ptr;
    ptr = &b;
    std::cout << *ptr;
 
    return 0;
}
```

c)
```c++
#include <iostream>
 
void printArray(int array[])
{
	for (const int &element : array)
		std::cout << element << ' ';
}
 
 
int main()
{
	int array[] { 8, 6, 4, 2, 0 };
	printArray(array);
 
	return 0;
}
```

d)
```c++
#include <iostream>
 
int main()
{
    double d(4.7);
    int *ptr = &d;
    std::cout << ptr;
 
    return 0;
}
```

## Task 6
Предположим, что мы хотим написать карточную игру.

a) В колоде карт находятся 52 уникальные карты: 13 достоинств (2, 3, 4, 5, 6, 7, 8, 9, 10, Валет, Дама, Король, Туз) и 4 масти (трефы, бубны, червы, пики). Создайте два перечисления: первое для масти, второе для достоинств карт.

### ***Подсказка:***
Добавьте в каждое перечисление еще по одному элементу, который будет обозначать длину этого перечисления.

b) Каждая карта должна быть представлена структурой Card, в которой хранится информация о достоинстве и масти карты (например, 4 бубны, король трефы). Создайте эту структуру.

c) Создайте функцию printCard(), параметром которой будет константная ссылка типа структуры Card, которая будет выводить значения достоинства и масти определенной карты в виде 2-буквенного кода (например, валет пики будет выводиться как VP).

d) Для представления целой колоды карт (52 карты) создайте массив deck (используя std::array) и инициализируйте каждый элемент определенной картой.

### ***Подсказка:***
Используйте оператор static_cast для конвертации целочисленной переменной в тип перечисления.

е) Напишите функцию printDeck(), которая в качестве параметра принимает константную ссылку на массив deck и выводит все значения (карты). Используйте цикл foreach.

f) Напишите функцию swapCard(), которая принимает две карты и меняет местами их значения.

g) Напишите функцию shuffleDeck() для перетасовки колоды карт. Для этого используйте цикл for с итерацией по массиву. Перетасовка карт должна произойти 52 раза. В цикле for выберите случайное число от 1 до 52 и вызовите swapCard(), параметрами которой будут текущая карта и карта, выбранная случайным образом. Добавьте в функцию main() возможность перетасовки и вывода уже обновленной (перетасованной) колоды карт.

### ***Подсказки:***
- Для генерации случайных чисел смотрите урок №71.
- Не забудьте в начале функции main() вызвать функцию srand().
- Если вы используете Visual Studio, то не забудьте перед генерацией случайного числа вызвать один раз функцию rand().

h) Напишите функцию getCardValue(), которая возвращает значение карты (например, 2 значит 2, 3 значит 3 и т.д., 10, валет, королева или король — это 10, туз — это 11).

## Task 7
Хорошо, настало время для серьезной игры! Давайте напишем упрощенную версию известной карточной игры «Blackjack» (русский аналог «Очко» или «21 очко»). Если вы не знакомы с этой игрой и её правилами, то вот ссылка на статью в Википедии о «Блэкджек».

Правила нашей версии «Blackjack» следующие:
- вначале дилер получает одну карту (в реальной жизни, дилер получает две карты, но одна лицевой стороной вниз, поэтому на данном этапе это не имеет значения);
- затем игрок получает две карты;
- игрок начинает;
- игрок может либо «взять» (hit), либо «удержаться» (stand);
- если игрок «удержался», то его ход завершен, и его результат подсчитывается на основе карт, которые у него есть;
- если игрок «берет», то он получает вторую карту, и значение этой карты добавляется к его уже имеющемуся результату;
- туз обычно считается как 1 или как 11. Чтобы было проще, мы будем считать его как 11;
- если у игрока в результате получается больше 21, то он проиграл;
- ход дилера выполняется после хода игрока;
- дилер берет карты до тех пор, пока его общий результат не достигнет 17 или более очков. Как только этот предел достигнут — дилер карт уже не берет;
- если у дилера больше 21-го, то дилер проиграл, а игрок победил;
- если же у дилера и у игрока до 21 очка, то выигрывает тот, у кого результат больше.

В нашей упрощенной версии «Blackjack» мы не будем отслеживать, какие конкретно карты были у игрока, а какие у дилера. Мы будем отслеживать только сумму значений карт, которые они получили. Так будет проще.

Начнем с кода, который у нас получился в задании №6. Создайте функцию playBlackjack(), которая возвращает true, если игрок побеждает, и false — если он проигрывает. Эта функция должна:
- Принимать перетасованную колоду карт (deck) в качестве параметра.
- Инициализировать указатель на первую карту (имя указателя — cardPtr). Это будет использоваться для раздачи карт из колоды.
- Иметь две целочисленные переменные для хранения результата игрока и дилера.
- Соответствовать правилам, приведенным выше.

  ### ***Подсказка:***
  Самый простой способ раздачи карт из колоды — это заставить указатель указывать на следующую карту в колоде (которая будет раздаваться). Всякий раз, когда нам нужно будет раздать карту, мы получаем значение текущей карты, а затем заставляем указатель указывать на следующую карту. Это можно сделать в одной строке кода:
  ```c++
  getCardValue(*cardPtr++);
  ```

  Здесь возвращается значение текущей карты (которое затем может быть добавлено к общему результату игрока или дилера) и указатель cardPtr переходит на следующую карту.

Протестируйте выполнение одиночной игры «Блэкджек» в функции main().